<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>여행 일정</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; color:#111;}
    .back { text-decoration:none; color:#2563eb; }
    h1 { margin: 8px 0 2px; }
    .muted { color:#6b7280; }
    .card { border:1px solid #e5e7eb; border-radius:12px; padding:16px; margin:12px 0; }
    .time { font-weight:600; width:72px; display:inline-block; }
    .title { font-weight:600; }
    .cat { font-size:12px; color:#6b7280; margin-left:6px; }
    .notes { margin-top:4px; color:#374151; }
    .err { color:#b91c1c; white-space:pre-wrap; }
    .skeleton { background:#f3f4f6; height:18px; border-radius:8px; margin:10px 0; width:60%; }
  </style>
</head>
<body>
<a class="back" href="/" aria-label="돌아가기">← 돌아가기</a>
<h1>여행 일정</h1>
<div id="meta" class="muted"></div>
<div id="list"></div>
<div id="error" class="err"></div>

<script>
  (async function main () {
    const $list = document.getElementById('list');
    const $meta = document.getElementById('meta');
    const $err  = document.getElementById('error');

    // 로딩 스켈레톤
    $list.innerHTML = '<div class="skeleton"></div><div class="skeleton" style="width:40%"></div>';

    // URL에서 id 추출
    const params = new URLSearchParams(location.search);
    const id = params.get('id');
    if (!id) {
      $list.innerHTML = '';
      $err.textContent = 'id 파라미터가 없습니다. 예) /itinerary.html?id=<생성된-UUID>';
      return;
    }

    // 여러 백엔드 모양을 모두 커버하는 엔드포인트/파싱 로직
    const candidates = [
      // 1) 쿼리 방식
      `/api/itineraries?id=${encodeURIComponent(id)}`,
      // 2) path 방식 (풀 오브젝트)
      `/api/itineraries/${encodeURIComponent(id)}`,
      // 3) path + 배열만 반환
      `/api/itineraries/${encodeURIComponent(id)}?shape=array`,
      // 4) items 전용
      `/api/itineraries/${encodeURIComponent(id)}/items`,
    ];

    let items = [];
    let lastResponseBody = null;
    let hitUrl = null;

    for (const url of candidates) {
      try {
        const res = await fetch(url, { headers: { 'Accept': 'application/json' }});
        if (!res.ok) continue;
        const data = await res.json();
        lastResponseBody = data;
        hitUrl = url;

        // 데이터 정규화: 배열이면 바로, 오브젝트면 여러 키 시도
        if (Array.isArray(data)) {
          items = data;
        } else if (data && typeof data === 'object') {
          const picks = ['itinerary','items','schedule','events','plans'];
          for (const key of picks) {
            if (Array.isArray(data[key]) && data[key].length) {
              items = data[key];
              break;
            }
          }
          // plan.itinerary / plan.items 형태도 지원
          if (!items.length && data.plan && typeof data.plan === 'object') {
            if (Array.isArray(data.plan.itinerary) && data.plan.itinerary.length) {
              items = data.plan.itinerary;
            } else if (Array.isArray(data.plan.items) && data.plan.items.length) {
              items = data.plan.items;
            }
          }
        }

        if (items && items.length) break; // 성공했으면 루프 종료
      } catch (e) {
        // 다음 후보 시도
      }
    }

    // 렌더
    const render = (arr) => {
      if (!arr || !arr.length) {
        $list.innerHTML = '<p class="muted">아직 일정이 비어 있어요.</p>';
        return;
      }
      const rows = arr.map((it, idx) => {
        const time = (it.time ?? '').toString();
        const title = (it.title ?? `일정 ${idx+1}`).toString();
        const cat = (it.category ?? '').toString();
        const notes = (it.notes ?? '').toString();

        return `
        <div class="card">
          <div><span class="time">${time || '--:--'}</span>
               <span class="title">${escapeHtml(title)}</span>
               ${cat ? `<span class="cat">#${escapeHtml(cat)}</span>` : ''}</div>
          ${notes ? `<div class="notes">${escapeHtml(notes)}</div>` : ''}
        </div>
      `;
      }).join('');
      $list.innerHTML = rows;
    };

    // 메타/디버그 표시
    const metaPieces = [];
    if (hitUrl) metaPieces.push(`소스: ${hitUrl}`);
    if (lastResponseBody && lastResponseBody.meta && lastResponseBody.meta.createdAt) {
      metaPieces.push(`생성: ${new Date(lastResponseBody.meta.createdAt).toLocaleString()}`);
    }
    $meta.textContent = metaPieces.join(' · ');

    render(items);

    // 에러/디버그 보조
    if (!items.length) {
      $err.textContent =
              '서버에서 일정을 찾지 못했습니다. Network 탭에서 실제 응답을 확인하세요.\n' +
              '백엔드는 itinerary/items/schedule/events/plans/배열 형태를 모두 지원하도록 컨트롤러가 구성되어 있습니다.';
    }

    // 유틸: XSS 방지
    function escapeHtml(s) {
      return s.replaceAll('&','&amp;').replaceAll('<','&lt;')
              .replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'",'&#39;');
    }
  })();
</script>
</body>
</html>
